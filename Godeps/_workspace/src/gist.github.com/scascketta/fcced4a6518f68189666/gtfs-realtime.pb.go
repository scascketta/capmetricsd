// Code generated by protoc-gen-go.
// source: gtfs-realtime.proto
// DO NOT EDIT!

/*
Package gtfs_realtime is a generated protocol buffer package.

It is generated from these files:
    gtfs_realtime.proto

It has these top-level messages:
    FeedMessage
    FeedHeader
    FeedEntity
    TripUpdate
    VehiclePosition
    Alert
    TimeRange
    Position
    TripDescriptor
    VehicleDescriptor
    EntitySelector
    TranslatedString
*/
package gtfs_realtime

import proto "github.com/scascketta/capmetro-data/Godeps/_workspace/src/github.com/golang/protobuf/proto"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = math.Inf

// Determines whether the current fetch is incremental.  Currently,
// DIFFERENTIAL mode is unsupported and behavior is unspecified for feeds
// that use this mode.  There are discussions on the GTFS-realtime mailing
// list around fully specifying the behavior of DIFFERENTIAL mode and the
// documentation will be updated when those discussions are finalized.
type FeedHeader_Incrementality int32

const (
	FeedHeader_FULL_DATASET FeedHeader_Incrementality = 0
	FeedHeader_DIFFERENTIAL FeedHeader_Incrementality = 1
)

var FeedHeader_Incrementality_name = map[int32]string{
	0: "FULL_DATASET",
	1: "DIFFERENTIAL",
}
var FeedHeader_Incrementality_value = map[string]int32{
	"FULL_DATASET": 0,
	"DIFFERENTIAL": 1,
}

func (x FeedHeader_Incrementality) Enum() *FeedHeader_Incrementality {
	p := new(FeedHeader_Incrementality)
	*p = x
	return p
}
func (x FeedHeader_Incrementality) String() string {
	return proto.EnumName(FeedHeader_Incrementality_name, int32(x))
}
func (x *FeedHeader_Incrementality) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(FeedHeader_Incrementality_value, data, "FeedHeader_Incrementality")
	if err != nil {
		return err
	}
	*x = FeedHeader_Incrementality(value)
	return nil
}

// The relation between this StopTime and the static schedule.
type TripUpdate_StopTimeUpdate_ScheduleRelationship int32

const (
	// The vehicle is proceeding in accordance with its static schedule of
	// stops, although not necessarily according to the times of the schedule.
	// At least one of arrival and departure must be provided. If the schedule
	// for this stop contains both arrival and departure times then so must
	// this update.
	TripUpdate_StopTimeUpdate_SCHEDULED TripUpdate_StopTimeUpdate_ScheduleRelationship = 0
	// The stop is skipped, i.e., the vehicle will not stop at this stop.
	// Arrival and departure are optional.
	TripUpdate_StopTimeUpdate_SKIPPED TripUpdate_StopTimeUpdate_ScheduleRelationship = 1
	// No data is given for this stop. The main intention for this value is to
	// give the predictions only for part of a trip, i.e., if the last update
	// for a trip has a NO_DATA specifier, then StopTimes for the rest of the
	// stops in the trip are considered to be unspecified as well.
	// Neither arrival nor departure should be supplied.
	TripUpdate_StopTimeUpdate_NO_DATA TripUpdate_StopTimeUpdate_ScheduleRelationship = 2
)

var TripUpdate_StopTimeUpdate_ScheduleRelationship_name = map[int32]string{
	0: "SCHEDULED",
	1: "SKIPPED",
	2: "NO_DATA",
}
var TripUpdate_StopTimeUpdate_ScheduleRelationship_value = map[string]int32{
	"SCHEDULED": 0,
	"SKIPPED":   1,
	"NO_DATA":   2,
}

func (x TripUpdate_StopTimeUpdate_ScheduleRelationship) Enum() *TripUpdate_StopTimeUpdate_ScheduleRelationship {
	p := new(TripUpdate_StopTimeUpdate_ScheduleRelationship)
	*p = x
	return p
}
func (x TripUpdate_StopTimeUpdate_ScheduleRelationship) String() string {
	return proto.EnumName(TripUpdate_StopTimeUpdate_ScheduleRelationship_name, int32(x))
}
func (x *TripUpdate_StopTimeUpdate_ScheduleRelationship) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(TripUpdate_StopTimeUpdate_ScheduleRelationship_value, data, "TripUpdate_StopTimeUpdate_ScheduleRelationship")
	if err != nil {
		return err
	}
	*x = TripUpdate_StopTimeUpdate_ScheduleRelationship(value)
	return nil
}

type VehiclePosition_VehicleStopStatus int32

const (
	// The vehicle is just about to arrive at the stop (on a stop
	// display, the vehicle symbol typically flashes).
	VehiclePosition_INCOMING_AT VehiclePosition_VehicleStopStatus = 0
	// The vehicle is standing at the stop.
	VehiclePosition_STOPPED_AT VehiclePosition_VehicleStopStatus = 1
	// The vehicle has departed and is in transit to the next stop.
	VehiclePosition_IN_TRANSIT_TO VehiclePosition_VehicleStopStatus = 2
)

var VehiclePosition_VehicleStopStatus_name = map[int32]string{
	0: "INCOMING_AT",
	1: "STOPPED_AT",
	2: "IN_TRANSIT_TO",
}
var VehiclePosition_VehicleStopStatus_value = map[string]int32{
	"INCOMING_AT":   0,
	"STOPPED_AT":    1,
	"IN_TRANSIT_TO": 2,
}

func (x VehiclePosition_VehicleStopStatus) Enum() *VehiclePosition_VehicleStopStatus {
	p := new(VehiclePosition_VehicleStopStatus)
	*p = x
	return p
}
func (x VehiclePosition_VehicleStopStatus) String() string {
	return proto.EnumName(VehiclePosition_VehicleStopStatus_name, int32(x))
}
func (x *VehiclePosition_VehicleStopStatus) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(VehiclePosition_VehicleStopStatus_value, data, "VehiclePosition_VehicleStopStatus")
	if err != nil {
		return err
	}
	*x = VehiclePosition_VehicleStopStatus(value)
	return nil
}

// Congestion level that is affecting this vehicle.
type VehiclePosition_CongestionLevel int32

const (
	VehiclePosition_UNKNOWN_CONGESTION_LEVEL VehiclePosition_CongestionLevel = 0
	VehiclePosition_RUNNING_SMOOTHLY         VehiclePosition_CongestionLevel = 1
	VehiclePosition_STOP_AND_GO              VehiclePosition_CongestionLevel = 2
	VehiclePosition_CONGESTION               VehiclePosition_CongestionLevel = 3
	VehiclePosition_SEVERE_CONGESTION        VehiclePosition_CongestionLevel = 4
)

var VehiclePosition_CongestionLevel_name = map[int32]string{
	0: "UNKNOWN_CONGESTION_LEVEL",
	1: "RUNNING_SMOOTHLY",
	2: "STOP_AND_GO",
	3: "CONGESTION",
	4: "SEVERE_CONGESTION",
}
var VehiclePosition_CongestionLevel_value = map[string]int32{
	"UNKNOWN_CONGESTION_LEVEL": 0,
	"RUNNING_SMOOTHLY":         1,
	"STOP_AND_GO":              2,
	"CONGESTION":               3,
	"SEVERE_CONGESTION":        4,
}

func (x VehiclePosition_CongestionLevel) Enum() *VehiclePosition_CongestionLevel {
	p := new(VehiclePosition_CongestionLevel)
	*p = x
	return p
}
func (x VehiclePosition_CongestionLevel) String() string {
	return proto.EnumName(VehiclePosition_CongestionLevel_name, int32(x))
}
func (x *VehiclePosition_CongestionLevel) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(VehiclePosition_CongestionLevel_value, data, "VehiclePosition_CongestionLevel")
	if err != nil {
		return err
	}
	*x = VehiclePosition_CongestionLevel(value)
	return nil
}

// The degree of passenger occupancy of the vehicle. This field is still
// experimental, and subject to change. It may be formally adopted in the
// future.
type VehiclePosition_OccupancyStatus int32

const (
	// The vehicle is considered empty by most measures, and has few or no
	// passengers onboard, but is still accepting passengers.
	VehiclePosition_EMPTY VehiclePosition_OccupancyStatus = 0
	// The vehicle has a relatively large percentage of seats available.
	// What percentage of free seats out of the total seats available is to be
	// considered large enough to fall into this category is determined at the
	// discretion of the producer.
	VehiclePosition_MANY_SEATS_AVAILABLE VehiclePosition_OccupancyStatus = 1
	// The vehicle has a relatively small percentage of seats available.
	// What percentage of free seats out of the total seats available is to be
	// considered small enough to fall into this category is determined at the
	// discretion of the feed producer.
	VehiclePosition_FEW_SEATS_AVAILABLE VehiclePosition_OccupancyStatus = 2
	// The vehicle can currently accommodate only standing passengers.
	VehiclePosition_STANDING_ROOM_ONLY VehiclePosition_OccupancyStatus = 3
	// The vehicle can currently accommodate only standing passengers
	// and has limited space for them.
	VehiclePosition_CRUSHED_STANDING_ROOM_ONLY VehiclePosition_OccupancyStatus = 4
	// The vehicle is considered full by most measures, but may still be
	// allowing passengers to board.
	VehiclePosition_FULL VehiclePosition_OccupancyStatus = 5
	// The vehicle is not accepting additional passengers.
	VehiclePosition_NOT_ACCEPTING_PASSENGERS VehiclePosition_OccupancyStatus = 6
)

var VehiclePosition_OccupancyStatus_name = map[int32]string{
	0: "EMPTY",
	1: "MANY_SEATS_AVAILABLE",
	2: "FEW_SEATS_AVAILABLE",
	3: "STANDING_ROOM_ONLY",
	4: "CRUSHED_STANDING_ROOM_ONLY",
	5: "FULL",
	6: "NOT_ACCEPTING_PASSENGERS",
}
var VehiclePosition_OccupancyStatus_value = map[string]int32{
	"EMPTY":                      0,
	"MANY_SEATS_AVAILABLE":       1,
	"FEW_SEATS_AVAILABLE":        2,
	"STANDING_ROOM_ONLY":         3,
	"CRUSHED_STANDING_ROOM_ONLY": 4,
	"FULL": 5,
	"NOT_ACCEPTING_PASSENGERS": 6,
}

func (x VehiclePosition_OccupancyStatus) Enum() *VehiclePosition_OccupancyStatus {
	p := new(VehiclePosition_OccupancyStatus)
	*p = x
	return p
}
func (x VehiclePosition_OccupancyStatus) String() string {
	return proto.EnumName(VehiclePosition_OccupancyStatus_name, int32(x))
}
func (x *VehiclePosition_OccupancyStatus) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(VehiclePosition_OccupancyStatus_value, data, "VehiclePosition_OccupancyStatus")
	if err != nil {
		return err
	}
	*x = VehiclePosition_OccupancyStatus(value)
	return nil
}

// Cause of this alert.
type Alert_Cause int32

const (
	Alert_UNKNOWN_CAUSE     Alert_Cause = 1
	Alert_OTHER_CAUSE       Alert_Cause = 2
	Alert_TECHNICAL_PROBLEM Alert_Cause = 3
	Alert_STRIKE            Alert_Cause = 4
	Alert_DEMONSTRATION     Alert_Cause = 5
	Alert_ACCIDENT          Alert_Cause = 6
	Alert_HOLIDAY           Alert_Cause = 7
	Alert_WEATHER           Alert_Cause = 8
	Alert_MAINTENANCE       Alert_Cause = 9
	Alert_CONSTRUCTION      Alert_Cause = 10
	Alert_POLICE_ACTIVITY   Alert_Cause = 11
	Alert_MEDICAL_EMERGENCY Alert_Cause = 12
)

var Alert_Cause_name = map[int32]string{
	1:  "UNKNOWN_CAUSE",
	2:  "OTHER_CAUSE",
	3:  "TECHNICAL_PROBLEM",
	4:  "STRIKE",
	5:  "DEMONSTRATION",
	6:  "ACCIDENT",
	7:  "HOLIDAY",
	8:  "WEATHER",
	9:  "MAINTENANCE",
	10: "CONSTRUCTION",
	11: "POLICE_ACTIVITY",
	12: "MEDICAL_EMERGENCY",
}
var Alert_Cause_value = map[string]int32{
	"UNKNOWN_CAUSE":     1,
	"OTHER_CAUSE":       2,
	"TECHNICAL_PROBLEM": 3,
	"STRIKE":            4,
	"DEMONSTRATION":     5,
	"ACCIDENT":          6,
	"HOLIDAY":           7,
	"WEATHER":           8,
	"MAINTENANCE":       9,
	"CONSTRUCTION":      10,
	"POLICE_ACTIVITY":   11,
	"MEDICAL_EMERGENCY": 12,
}

func (x Alert_Cause) Enum() *Alert_Cause {
	p := new(Alert_Cause)
	*p = x
	return p
}
func (x Alert_Cause) String() string {
	return proto.EnumName(Alert_Cause_name, int32(x))
}
func (x *Alert_Cause) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Alert_Cause_value, data, "Alert_Cause")
	if err != nil {
		return err
	}
	*x = Alert_Cause(value)
	return nil
}

// What is the effect of this problem on the affected entity.
type Alert_Effect int32

const (
	Alert_NO_SERVICE      Alert_Effect = 1
	Alert_REDUCED_SERVICE Alert_Effect = 2
	// We don't care about INsignificant delays: they are hard to detect, have
	// little impact on the user, and would clutter the results as they are too
	// frequent.
	Alert_SIGNIFICANT_DELAYS Alert_Effect = 3
	Alert_DETOUR             Alert_Effect = 4
	Alert_ADDITIONAL_SERVICE Alert_Effect = 5
	Alert_MODIFIED_SERVICE   Alert_Effect = 6
	Alert_OTHER_EFFECT       Alert_Effect = 7
	Alert_UNKNOWN_EFFECT     Alert_Effect = 8
	Alert_STOP_MOVED         Alert_Effect = 9
)

var Alert_Effect_name = map[int32]string{
	1: "NO_SERVICE",
	2: "REDUCED_SERVICE",
	3: "SIGNIFICANT_DELAYS",
	4: "DETOUR",
	5: "ADDITIONAL_SERVICE",
	6: "MODIFIED_SERVICE",
	7: "OTHER_EFFECT",
	8: "UNKNOWN_EFFECT",
	9: "STOP_MOVED",
}
var Alert_Effect_value = map[string]int32{
	"NO_SERVICE":         1,
	"REDUCED_SERVICE":    2,
	"SIGNIFICANT_DELAYS": 3,
	"DETOUR":             4,
	"ADDITIONAL_SERVICE": 5,
	"MODIFIED_SERVICE":   6,
	"OTHER_EFFECT":       7,
	"UNKNOWN_EFFECT":     8,
	"STOP_MOVED":         9,
}

func (x Alert_Effect) Enum() *Alert_Effect {
	p := new(Alert_Effect)
	*p = x
	return p
}
func (x Alert_Effect) String() string {
	return proto.EnumName(Alert_Effect_name, int32(x))
}
func (x *Alert_Effect) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Alert_Effect_value, data, "Alert_Effect")
	if err != nil {
		return err
	}
	*x = Alert_Effect(value)
	return nil
}

// The relation between this trip and the static schedule. If a trip is done
// in accordance with temporary schedule, not reflected in GTFS, then it
// shouldn't be marked as SCHEDULED, but likely as ADDED.
type TripDescriptor_ScheduleRelationship int32

const (
	// Trip that is running in accordance with its GTFS schedule, or is close
	// enough to the scheduled trip to be associated with it.
	TripDescriptor_SCHEDULED TripDescriptor_ScheduleRelationship = 0
	// An extra trip that was added in addition to a running schedule, for
	// example, to replace a broken vehicle or to respond to sudden passenger
	// load.
	TripDescriptor_ADDED TripDescriptor_ScheduleRelationship = 1
	// A trip that is running with no schedule associated to it, for example, if
	// there is no schedule at all.
	TripDescriptor_UNSCHEDULED TripDescriptor_ScheduleRelationship = 2
	// A trip that existed in the schedule but was removed.
	TripDescriptor_CANCELED TripDescriptor_ScheduleRelationship = 3
)

var TripDescriptor_ScheduleRelationship_name = map[int32]string{
	0: "SCHEDULED",
	1: "ADDED",
	2: "UNSCHEDULED",
	3: "CANCELED",
}
var TripDescriptor_ScheduleRelationship_value = map[string]int32{
	"SCHEDULED":   0,
	"ADDED":       1,
	"UNSCHEDULED": 2,
	"CANCELED":    3,
}

func (x TripDescriptor_ScheduleRelationship) Enum() *TripDescriptor_ScheduleRelationship {
	p := new(TripDescriptor_ScheduleRelationship)
	*p = x
	return p
}
func (x TripDescriptor_ScheduleRelationship) String() string {
	return proto.EnumName(TripDescriptor_ScheduleRelationship_name, int32(x))
}
func (x *TripDescriptor_ScheduleRelationship) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(TripDescriptor_ScheduleRelationship_value, data, "TripDescriptor_ScheduleRelationship")
	if err != nil {
		return err
	}
	*x = TripDescriptor_ScheduleRelationship(value)
	return nil
}

// The contents of a feed message.
// A feed is a continuous stream of feed messages. Each message in the stream is
// obtained as a response to an appropriate HTTP GET request.
// A realtime feed is always defined with relation to an existing GTFS feed.
// All the entity ids are resolved with respect to the GTFS feed.
//
// A feed depends on some external configuration:
// - The corresponding GTFS feed.
// - Feed application (updates, positions or alerts). A feed should contain only
//   items of one specified application; all the other entities will be ignored.
// - Polling frequency
type FeedMessage struct {
	// Metadata about this feed and feed message.
	Header *FeedHeader `protobuf:"bytes,1,req,name=header" json:"header,omitempty"`
	// Contents of the feed.
	Entity           []*FeedEntity `protobuf:"bytes,2,rep,name=entity" json:"entity,omitempty"`
	XXX_unrecognized []byte        `json:"-"`
}

func (m *FeedMessage) Reset()         { *m = FeedMessage{} }
func (m *FeedMessage) String() string { return proto.CompactTextString(m) }
func (*FeedMessage) ProtoMessage()    {}

func (m *FeedMessage) GetHeader() *FeedHeader {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *FeedMessage) GetEntity() []*FeedEntity {
	if m != nil {
		return m.Entity
	}
	return nil
}

// Metadata about a feed, included in feed messages.
type FeedHeader struct {
	// Version of the feed specification.
	// The current version is 1.0.
	GtfsRealtimeVersion *string                    `protobuf:"bytes,1,req,name=gtfs_realtime_version" json:"gtfs_realtime_version,omitempty"`
	Incrementality      *FeedHeader_Incrementality `protobuf:"varint,2,opt,name=incrementality,enum=main.FeedHeader_Incrementality,def=0" json:"incrementality,omitempty"`
	// This timestamp identifies the moment when the content of this feed has been
	// created (in server time). In POSIX time (i.e., number of seconds since
	// January 1st 1970 00:00:00 UTC).
	Timestamp        *uint64                   `protobuf:"varint,3,opt,name=timestamp" json:"timestamp,omitempty"`
	XXX_extensions   map[int32]proto.Extension `json:"-"`
	XXX_unrecognized []byte                    `json:"-"`
}

func (m *FeedHeader) Reset()         { *m = FeedHeader{} }
func (m *FeedHeader) String() string { return proto.CompactTextString(m) }
func (*FeedHeader) ProtoMessage()    {}

var extRange_FeedHeader = []proto.ExtensionRange{
	{1000, 1999},
}

func (*FeedHeader) ExtensionRangeArray() []proto.ExtensionRange {
	return extRange_FeedHeader
}
func (m *FeedHeader) ExtensionMap() map[int32]proto.Extension {
	if m.XXX_extensions == nil {
		m.XXX_extensions = make(map[int32]proto.Extension)
	}
	return m.XXX_extensions
}

const Default_FeedHeader_Incrementality FeedHeader_Incrementality = FeedHeader_FULL_DATASET

func (m *FeedHeader) GetGtfsRealtimeVersion() string {
	if m != nil && m.GtfsRealtimeVersion != nil {
		return *m.GtfsRealtimeVersion
	}
	return ""
}

func (m *FeedHeader) GetIncrementality() FeedHeader_Incrementality {
	if m != nil && m.Incrementality != nil {
		return *m.Incrementality
	}
	return Default_FeedHeader_Incrementality
}

func (m *FeedHeader) GetTimestamp() uint64 {
	if m != nil && m.Timestamp != nil {
		return *m.Timestamp
	}
	return 0
}

// A definition (or update) of an entity in the transit feed.
type FeedEntity struct {
	// The ids are used only to provide incrementality support. The id should be
	// unique within a FeedMessage. Consequent FeedMessages may contain
	// FeedEntities with the same id. In case of a DIFFERENTIAL update the new
	// FeedEntity with some id will replace the old FeedEntity with the same id
	// (or delete it - see is_deleted below).
	// The actual GTFS entities (e.g. stations, routes, trips) referenced by the
	// feed must be specified by explicit selectors (see EntitySelector below for
	// more info).
	Id *string `protobuf:"bytes,1,req,name=id" json:"id,omitempty"`
	// Whether this entity is to be deleted. Relevant only for incremental
	// fetches.
	IsDeleted *bool `protobuf:"varint,2,opt,name=is_deleted,def=0" json:"is_deleted,omitempty"`
	// Data about the entity itself. Exactly one of the following fields must be
	// present (unless the entity is being deleted).
	TripUpdate       *TripUpdate      `protobuf:"bytes,3,opt,name=trip_update" json:"trip_update,omitempty"`
	Vehicle          *VehiclePosition `protobuf:"bytes,4,opt,name=vehicle" json:"vehicle,omitempty"`
	Alert            *Alert           `protobuf:"bytes,5,opt,name=alert" json:"alert,omitempty"`
	XXX_unrecognized []byte           `json:"-"`
}

func (m *FeedEntity) Reset()         { *m = FeedEntity{} }
func (m *FeedEntity) String() string { return proto.CompactTextString(m) }
func (*FeedEntity) ProtoMessage()    {}

const Default_FeedEntity_IsDeleted bool = false

func (m *FeedEntity) GetId() string {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return ""
}

func (m *FeedEntity) GetIsDeleted() bool {
	if m != nil && m.IsDeleted != nil {
		return *m.IsDeleted
	}
	return Default_FeedEntity_IsDeleted
}

func (m *FeedEntity) GetTripUpdate() *TripUpdate {
	if m != nil {
		return m.TripUpdate
	}
	return nil
}

func (m *FeedEntity) GetVehicle() *VehiclePosition {
	if m != nil {
		return m.Vehicle
	}
	return nil
}

func (m *FeedEntity) GetAlert() *Alert {
	if m != nil {
		return m.Alert
	}
	return nil
}

// Realtime update of the progress of a vehicle along a trip.
// Depending on the value of ScheduleRelationship, a TripUpdate can specify:
// - A trip that proceeds along the schedule.
// - A trip that proceeds along a route but has no fixed schedule.
// - A trip that have been added or removed with regard to schedule.
//
// The updates can be for future, predicted arrival/departure events, or for
// past events that already occurred.
// Normally, updates should get more precise and more certain (see
// uncertainty below) as the events gets closer to current time.
// Even if that is not possible, the information for past events should be
// precise and certain. In particular, if an update points to time in the past
// but its update's uncertainty is not 0, the client should conclude that the
// update is a (wrong) prediction and that the trip has not completed yet.
//
// Note that the update can describe a trip that is already completed.
// To this end, it is enough to provide an update for the last stop of the trip.
// If the time of that is in the past, the client will conclude from that that
// the whole trip is in the past (it is possible, although inconsequential, to
// also provide updates for preceding stops).
// This option is most relevant for a trip that has completed ahead of schedule,
// but according to the schedule, the trip is still proceeding at the current
// time. Removing the updates for this trip could make the client assume
// that the trip is still proceeding.
// Note that the feed provider is allowed, but not required, to purge past
// updates - this is one case where this would be practically useful.
type TripUpdate struct {
	// The Trip that this message applies to. There can be at most one
	// TripUpdate entity for each actual trip instance.
	// If there is none, that means there is no prediction information available.
	// It does *not* mean that the trip is progressing according to schedule.
	Trip *TripDescriptor `protobuf:"bytes,1,req,name=trip" json:"trip,omitempty"`
	// Additional information on the vehicle that is serving this trip.
	Vehicle *VehicleDescriptor `protobuf:"bytes,3,opt,name=vehicle" json:"vehicle,omitempty"`
	// Updates to StopTimes for the trip (both future, i.e., predictions, and in
	// some cases, past ones, i.e., those that already happened).
	// The updates must be sorted by stop_sequence, and apply for all the
	// following stops of the trip up to the next specified one.
	//
	// Example 1:
	// For a trip with 20 stops, a StopTimeUpdate with arrival delay and departure
	// delay of 0 for stop_sequence of the current stop means that the trip is
	// exactly on time.
	//
	// Example 2:
	// For the same trip instance, 3 StopTimeUpdates are provided:
	// - delay of 5 min for stop_sequence 3
	// - delay of 1 min for stop_sequence 8
	// - delay of unspecified duration for stop_sequence 10
	// This will be interpreted as:
	// - stop_sequences 3,4,5,6,7 have delay of 5 min.
	// - stop_sequences 8,9 have delay of 1 min.
	// - stop_sequences 10,... have unknown delay.
	StopTimeUpdate []*TripUpdate_StopTimeUpdate `protobuf:"bytes,2,rep,name=stop_time_update" json:"stop_time_update,omitempty"`
	// Moment at which the vehicle's real-time progress was measured. In POSIX
	// time (i.e., the number of seconds since January 1st 1970 00:00:00 UTC).
	Timestamp        *uint64                   `protobuf:"varint,4,opt,name=timestamp" json:"timestamp,omitempty"`
	XXX_extensions   map[int32]proto.Extension `json:"-"`
	XXX_unrecognized []byte                    `json:"-"`
}

func (m *TripUpdate) Reset()         { *m = TripUpdate{} }
func (m *TripUpdate) String() string { return proto.CompactTextString(m) }
func (*TripUpdate) ProtoMessage()    {}

var extRange_TripUpdate = []proto.ExtensionRange{
	{1000, 1999},
}

func (*TripUpdate) ExtensionRangeArray() []proto.ExtensionRange {
	return extRange_TripUpdate
}
func (m *TripUpdate) ExtensionMap() map[int32]proto.Extension {
	if m.XXX_extensions == nil {
		m.XXX_extensions = make(map[int32]proto.Extension)
	}
	return m.XXX_extensions
}

func (m *TripUpdate) GetTrip() *TripDescriptor {
	if m != nil {
		return m.Trip
	}
	return nil
}

func (m *TripUpdate) GetVehicle() *VehicleDescriptor {
	if m != nil {
		return m.Vehicle
	}
	return nil
}

func (m *TripUpdate) GetStopTimeUpdate() []*TripUpdate_StopTimeUpdate {
	if m != nil {
		return m.StopTimeUpdate
	}
	return nil
}

func (m *TripUpdate) GetTimestamp() uint64 {
	if m != nil && m.Timestamp != nil {
		return *m.Timestamp
	}
	return 0
}

// Timing information for a single predicted event (either arrival or
// departure).
// Timing consists of delay and/or estimated time, and uncertainty.
// - delay should be used when the prediction is given relative to some
//   existing schedule in GTFS.
// - time should be given whether there is a predicted schedule or not. If
//   both time and delay are specified, time will take precedence
//   (although normally, time, if given for a scheduled trip, should be
//   equal to scheduled time in GTFS + delay).
//
// Uncertainty applies equally to both time and delay.
// The uncertainty roughly specifies the expected error in true delay (but
// note, we don't yet define its precise statistical meaning). It's possible
// for the uncertainty to be 0, for example for trains that are driven under
// computer timing control.
type TripUpdate_StopTimeEvent struct {
	// Delay (in seconds) can be positive (meaning that the vehicle is late) or
	// negative (meaning that the vehicle is ahead of schedule). Delay of 0
	// means that the vehicle is exactly on time.
	Delay *int32 `protobuf:"varint,1,opt,name=delay" json:"delay,omitempty"`
	// Event as absolute time.
	// In Unix time (i.e., number of seconds since January 1st 1970 00:00:00
	// UTC).
	Time *int64 `protobuf:"varint,2,opt,name=time" json:"time,omitempty"`
	// If uncertainty is omitted, it is interpreted as unknown.
	// If the prediction is unknown or too uncertain, the delay (or time) field
	// should be empty. In such case, the uncertainty field is ignored.
	// To specify a completely certain prediction, set its uncertainty to 0.
	Uncertainty      *int32                    `protobuf:"varint,3,opt,name=uncertainty" json:"uncertainty,omitempty"`
	XXX_extensions   map[int32]proto.Extension `json:"-"`
	XXX_unrecognized []byte                    `json:"-"`
}

func (m *TripUpdate_StopTimeEvent) Reset()         { *m = TripUpdate_StopTimeEvent{} }
func (m *TripUpdate_StopTimeEvent) String() string { return proto.CompactTextString(m) }
func (*TripUpdate_StopTimeEvent) ProtoMessage()    {}

var extRange_TripUpdate_StopTimeEvent = []proto.ExtensionRange{
	{1000, 1999},
}

func (*TripUpdate_StopTimeEvent) ExtensionRangeArray() []proto.ExtensionRange {
	return extRange_TripUpdate_StopTimeEvent
}
func (m *TripUpdate_StopTimeEvent) ExtensionMap() map[int32]proto.Extension {
	if m.XXX_extensions == nil {
		m.XXX_extensions = make(map[int32]proto.Extension)
	}
	return m.XXX_extensions
}

func (m *TripUpdate_StopTimeEvent) GetDelay() int32 {
	if m != nil && m.Delay != nil {
		return *m.Delay
	}
	return 0
}

func (m *TripUpdate_StopTimeEvent) GetTime() int64 {
	if m != nil && m.Time != nil {
		return *m.Time
	}
	return 0
}

func (m *TripUpdate_StopTimeEvent) GetUncertainty() int32 {
	if m != nil && m.Uncertainty != nil {
		return *m.Uncertainty
	}
	return 0
}

// Realtime update for arrival and/or departure events for a given stop on a
// trip. Updates can be supplied for both past and future events.
// The producer is allowed, although not required, to drop past events.
type TripUpdate_StopTimeUpdate struct {
	// Must be the same as in stop_times.txt in the corresponding GTFS feed.
	StopSequence *uint32 `protobuf:"varint,1,opt,name=stop_sequence" json:"stop_sequence,omitempty"`
	// Must be the same as in stops.txt in the corresponding GTFS feed.
	StopId               *string                                         `protobuf:"bytes,4,opt,name=stop_id" json:"stop_id,omitempty"`
	Arrival              *TripUpdate_StopTimeEvent                       `protobuf:"bytes,2,opt,name=arrival" json:"arrival,omitempty"`
	Departure            *TripUpdate_StopTimeEvent                       `protobuf:"bytes,3,opt,name=departure" json:"departure,omitempty"`
	ScheduleRelationship *TripUpdate_StopTimeUpdate_ScheduleRelationship `protobuf:"varint,5,opt,name=schedule_relationship,enum=main.TripUpdate_StopTimeUpdate_ScheduleRelationship,def=0" json:"schedule_relationship,omitempty"`
	XXX_extensions       map[int32]proto.Extension                       `json:"-"`
	XXX_unrecognized     []byte                                          `json:"-"`
}

func (m *TripUpdate_StopTimeUpdate) Reset()         { *m = TripUpdate_StopTimeUpdate{} }
func (m *TripUpdate_StopTimeUpdate) String() string { return proto.CompactTextString(m) }
func (*TripUpdate_StopTimeUpdate) ProtoMessage()    {}

var extRange_TripUpdate_StopTimeUpdate = []proto.ExtensionRange{
	{1000, 1999},
}

func (*TripUpdate_StopTimeUpdate) ExtensionRangeArray() []proto.ExtensionRange {
	return extRange_TripUpdate_StopTimeUpdate
}
func (m *TripUpdate_StopTimeUpdate) ExtensionMap() map[int32]proto.Extension {
	if m.XXX_extensions == nil {
		m.XXX_extensions = make(map[int32]proto.Extension)
	}
	return m.XXX_extensions
}

const Default_TripUpdate_StopTimeUpdate_ScheduleRelationship TripUpdate_StopTimeUpdate_ScheduleRelationship = TripUpdate_StopTimeUpdate_SCHEDULED

func (m *TripUpdate_StopTimeUpdate) GetStopSequence() uint32 {
	if m != nil && m.StopSequence != nil {
		return *m.StopSequence
	}
	return 0
}

func (m *TripUpdate_StopTimeUpdate) GetStopId() string {
	if m != nil && m.StopId != nil {
		return *m.StopId
	}
	return ""
}

func (m *TripUpdate_StopTimeUpdate) GetArrival() *TripUpdate_StopTimeEvent {
	if m != nil {
		return m.Arrival
	}
	return nil
}

func (m *TripUpdate_StopTimeUpdate) GetDeparture() *TripUpdate_StopTimeEvent {
	if m != nil {
		return m.Departure
	}
	return nil
}

func (m *TripUpdate_StopTimeUpdate) GetScheduleRelationship() TripUpdate_StopTimeUpdate_ScheduleRelationship {
	if m != nil && m.ScheduleRelationship != nil {
		return *m.ScheduleRelationship
	}
	return Default_TripUpdate_StopTimeUpdate_ScheduleRelationship
}

// Realtime positioning information for a given vehicle.
type VehiclePosition struct {
	// The Trip that this vehicle is serving.
	// Can be empty or partial if the vehicle can not be identified with a given
	// trip instance.
	Trip *TripDescriptor `protobuf:"bytes,1,opt,name=trip" json:"trip,omitempty"`
	// Additional information on the vehicle that is serving this trip.
	Vehicle *VehicleDescriptor `protobuf:"bytes,8,opt,name=vehicle" json:"vehicle,omitempty"`
	// Current position of this vehicle.
	Position *Position `protobuf:"bytes,2,opt,name=position" json:"position,omitempty"`
	// The stop sequence index of the current stop. The meaning of
	// current_stop_sequence (i.e., the stop that it refers to) is determined by
	// current_status.
	// If current_status is missing IN_TRANSIT_TO is assumed.
	CurrentStopSequence *uint32 `protobuf:"varint,3,opt,name=current_stop_sequence" json:"current_stop_sequence,omitempty"`
	// Identifies the current stop. The value must be the same as in stops.txt in
	// the corresponding GTFS feed.
	StopId *string `protobuf:"bytes,7,opt,name=stop_id" json:"stop_id,omitempty"`
	// The exact status of the vehicle with respect to the current stop.
	// Ignored if current_stop_sequence is missing.
	CurrentStatus *VehiclePosition_VehicleStopStatus `protobuf:"varint,4,opt,name=current_status,enum=main.VehiclePosition_VehicleStopStatus,def=2" json:"current_status,omitempty"`
	// Moment at which the vehicle's position was measured. In POSIX time
	// (i.e., number of seconds since January 1st 1970 00:00:00 UTC).
	Timestamp        *uint64                          `protobuf:"varint,5,opt,name=timestamp" json:"timestamp,omitempty"`
	CongestionLevel  *VehiclePosition_CongestionLevel `protobuf:"varint,6,opt,name=congestion_level,enum=main.VehiclePosition_CongestionLevel" json:"congestion_level,omitempty"`
	OccupancyStatus  *VehiclePosition_OccupancyStatus `protobuf:"varint,9,opt,name=occupancy_status,enum=main.VehiclePosition_OccupancyStatus" json:"occupancy_status,omitempty"`
	XXX_extensions   map[int32]proto.Extension        `json:"-"`
	XXX_unrecognized []byte                           `json:"-"`
}

func (m *VehiclePosition) Reset()         { *m = VehiclePosition{} }
func (m *VehiclePosition) String() string { return proto.CompactTextString(m) }
func (*VehiclePosition) ProtoMessage()    {}

var extRange_VehiclePosition = []proto.ExtensionRange{
	{1000, 1999},
}

func (*VehiclePosition) ExtensionRangeArray() []proto.ExtensionRange {
	return extRange_VehiclePosition
}
func (m *VehiclePosition) ExtensionMap() map[int32]proto.Extension {
	if m.XXX_extensions == nil {
		m.XXX_extensions = make(map[int32]proto.Extension)
	}
	return m.XXX_extensions
}

const Default_VehiclePosition_CurrentStatus VehiclePosition_VehicleStopStatus = VehiclePosition_IN_TRANSIT_TO

func (m *VehiclePosition) GetTrip() *TripDescriptor {
	if m != nil {
		return m.Trip
	}
	return nil
}

func (m *VehiclePosition) GetVehicle() *VehicleDescriptor {
	if m != nil {
		return m.Vehicle
	}
	return nil
}

func (m *VehiclePosition) GetPosition() *Position {
	if m != nil {
		return m.Position
	}
	return nil
}

func (m *VehiclePosition) GetCurrentStopSequence() uint32 {
	if m != nil && m.CurrentStopSequence != nil {
		return *m.CurrentStopSequence
	}
	return 0
}

func (m *VehiclePosition) GetStopId() string {
	if m != nil && m.StopId != nil {
		return *m.StopId
	}
	return ""
}

func (m *VehiclePosition) GetCurrentStatus() VehiclePosition_VehicleStopStatus {
	if m != nil && m.CurrentStatus != nil {
		return *m.CurrentStatus
	}
	return Default_VehiclePosition_CurrentStatus
}

func (m *VehiclePosition) GetTimestamp() uint64 {
	if m != nil && m.Timestamp != nil {
		return *m.Timestamp
	}
	return 0
}

func (m *VehiclePosition) GetCongestionLevel() VehiclePosition_CongestionLevel {
	if m != nil && m.CongestionLevel != nil {
		return *m.CongestionLevel
	}
	return VehiclePosition_UNKNOWN_CONGESTION_LEVEL
}

func (m *VehiclePosition) GetOccupancyStatus() VehiclePosition_OccupancyStatus {
	if m != nil && m.OccupancyStatus != nil {
		return *m.OccupancyStatus
	}
	return VehiclePosition_EMPTY
}

// An alert, indicating some sort of incident in the public transit network.
type Alert struct {
	// Time when the alert should be shown to the user. If missing, the
	// alert will be shown as long as it appears in the feed.
	// If multiple ranges are given, the alert will be shown during all of them.
	ActivePeriod []*TimeRange `protobuf:"bytes,1,rep,name=active_period" json:"active_period,omitempty"`
	// Entities whose users we should notify of this alert.
	InformedEntity []*EntitySelector `protobuf:"bytes,5,rep,name=informed_entity" json:"informed_entity,omitempty"`
	Cause          *Alert_Cause      `protobuf:"varint,6,opt,name=cause,enum=main.Alert_Cause,def=1" json:"cause,omitempty"`
	Effect         *Alert_Effect     `protobuf:"varint,7,opt,name=effect,enum=main.Alert_Effect,def=8" json:"effect,omitempty"`
	// The URL which provides additional information about the alert.
	Url *TranslatedString `protobuf:"bytes,8,opt,name=url" json:"url,omitempty"`
	// Alert header. Contains a short summary of the alert text as plain-text.
	HeaderText *TranslatedString `protobuf:"bytes,10,opt,name=header_text" json:"header_text,omitempty"`
	// Full description for the alert as plain-text. The information in the
	// description should add to the information of the header.
	DescriptionText  *TranslatedString         `protobuf:"bytes,11,opt,name=description_text" json:"description_text,omitempty"`
	XXX_extensions   map[int32]proto.Extension `json:"-"`
	XXX_unrecognized []byte                    `json:"-"`
}

func (m *Alert) Reset()         { *m = Alert{} }
func (m *Alert) String() string { return proto.CompactTextString(m) }
func (*Alert) ProtoMessage()    {}

var extRange_Alert = []proto.ExtensionRange{
	{1000, 1999},
}

func (*Alert) ExtensionRangeArray() []proto.ExtensionRange {
	return extRange_Alert
}
func (m *Alert) ExtensionMap() map[int32]proto.Extension {
	if m.XXX_extensions == nil {
		m.XXX_extensions = make(map[int32]proto.Extension)
	}
	return m.XXX_extensions
}

const Default_Alert_Cause Alert_Cause = Alert_UNKNOWN_CAUSE
const Default_Alert_Effect Alert_Effect = Alert_UNKNOWN_EFFECT

func (m *Alert) GetActivePeriod() []*TimeRange {
	if m != nil {
		return m.ActivePeriod
	}
	return nil
}

func (m *Alert) GetInformedEntity() []*EntitySelector {
	if m != nil {
		return m.InformedEntity
	}
	return nil
}

func (m *Alert) GetCause() Alert_Cause {
	if m != nil && m.Cause != nil {
		return *m.Cause
	}
	return Default_Alert_Cause
}

func (m *Alert) GetEffect() Alert_Effect {
	if m != nil && m.Effect != nil {
		return *m.Effect
	}
	return Default_Alert_Effect
}

func (m *Alert) GetUrl() *TranslatedString {
	if m != nil {
		return m.Url
	}
	return nil
}

func (m *Alert) GetHeaderText() *TranslatedString {
	if m != nil {
		return m.HeaderText
	}
	return nil
}

func (m *Alert) GetDescriptionText() *TranslatedString {
	if m != nil {
		return m.DescriptionText
	}
	return nil
}

// A time interval. The interval is considered active at time 't' if 't' is
// greater than or equal to the start time and less than the end time.
type TimeRange struct {
	// Start time, in POSIX time (i.e., number of seconds since January 1st 1970
	// 00:00:00 UTC).
	// If missing, the interval starts at minus infinity.
	Start *uint64 `protobuf:"varint,1,opt,name=start" json:"start,omitempty"`
	// End time, in POSIX time (i.e., number of seconds since January 1st 1970
	// 00:00:00 UTC).
	// If missing, the interval ends at plus infinity.
	End              *uint64 `protobuf:"varint,2,opt,name=end" json:"end,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *TimeRange) Reset()         { *m = TimeRange{} }
func (m *TimeRange) String() string { return proto.CompactTextString(m) }
func (*TimeRange) ProtoMessage()    {}

func (m *TimeRange) GetStart() uint64 {
	if m != nil && m.Start != nil {
		return *m.Start
	}
	return 0
}

func (m *TimeRange) GetEnd() uint64 {
	if m != nil && m.End != nil {
		return *m.End
	}
	return 0
}

// A position.
type Position struct {
	// Degrees North, in the WGS-84 coordinate system.
	Latitude *float32 `protobuf:"fixed32,1,req,name=latitude" json:"latitude,omitempty"`
	// Degrees East, in the WGS-84 coordinate system.
	Longitude *float32 `protobuf:"fixed32,2,req,name=longitude" json:"longitude,omitempty"`
	// Bearing, in degrees, clockwise from North, i.e., 0 is North and 90 is East.
	// This can be the compass bearing, or the direction towards the next stop
	// or intermediate location.
	// This should not be direction deduced from the sequence of previous
	// positions, which can be computed from previous data.
	Bearing *float32 `protobuf:"fixed32,3,opt,name=bearing" json:"bearing,omitempty"`
	// Odometer value, in meters.
	Odometer *float64 `protobuf:"fixed64,4,opt,name=odometer" json:"odometer,omitempty"`
	// Momentary speed measured by the vehicle, in meters per second.
	Speed            *float32                  `protobuf:"fixed32,5,opt,name=speed" json:"speed,omitempty"`
	XXX_extensions   map[int32]proto.Extension `json:"-"`
	XXX_unrecognized []byte                    `json:"-"`
}

func (m *Position) Reset()         { *m = Position{} }
func (m *Position) String() string { return proto.CompactTextString(m) }
func (*Position) ProtoMessage()    {}

var extRange_Position = []proto.ExtensionRange{
	{1000, 1999},
}

func (*Position) ExtensionRangeArray() []proto.ExtensionRange {
	return extRange_Position
}
func (m *Position) ExtensionMap() map[int32]proto.Extension {
	if m.XXX_extensions == nil {
		m.XXX_extensions = make(map[int32]proto.Extension)
	}
	return m.XXX_extensions
}

func (m *Position) GetLatitude() float32 {
	if m != nil && m.Latitude != nil {
		return *m.Latitude
	}
	return 0
}

func (m *Position) GetLongitude() float32 {
	if m != nil && m.Longitude != nil {
		return *m.Longitude
	}
	return 0
}

func (m *Position) GetBearing() float32 {
	if m != nil && m.Bearing != nil {
		return *m.Bearing
	}
	return 0
}

func (m *Position) GetOdometer() float64 {
	if m != nil && m.Odometer != nil {
		return *m.Odometer
	}
	return 0
}

func (m *Position) GetSpeed() float32 {
	if m != nil && m.Speed != nil {
		return *m.Speed
	}
	return 0
}

// A descriptor that identifies an instance of a GTFS trip, or all instances of
// a trip along a route.
// - To specify a single trip instance, the trip_id (and if necessary,
//   start_time) is set. If route_id is also set, then it should be same as one
//   that the given trip corresponds to.
// - To specify all the trips along a given route, only the route_id should be
//   set. Note that if the trip_id is not known, then stop sequence ids in
//   TripUpdate are not sufficient, and stop_ids must be provided as well. In
//   addition, absolute arrival/departure times must be provided.
type TripDescriptor struct {
	// The trip_id from the GTFS feed that this selector refers to.
	// For non frequency expanded trips, this field is enough to uniquely identify
	// the trip. For frequency expanded, start_time and start_date might also be
	// necessary.
	TripId *string `protobuf:"bytes,1,opt,name=trip_id" json:"trip_id,omitempty"`
	// The route_id from the GTFS that this selector refers to.
	RouteId *string `protobuf:"bytes,5,opt,name=route_id" json:"route_id,omitempty"`
	// The scheduled start time of this trip instance.
	// This field should be given only if the trip is frequency-expanded in the
	// GTFS feed. The value must precisely correspond to start_time specified for
	// the route in the GTFS feed plus some multiple of headway_secs.
	// Format of the field is same as that of GTFS/frequencies.txt/start_time,
	// e.g., 11:15:35 or 25:15:35.
	StartTime *string `protobuf:"bytes,2,opt,name=start_time" json:"start_time,omitempty"`
	// The scheduled start date of this trip instance.
	// Must be provided to disambiguate trips that are so late as to collide with
	// a scheduled trip on a next day. For example, for a train that departs 8:00
	// and 20:00 every day, and is 12 hours late, there would be two distinct
	// trips on the same time.
	// This field can be provided but is not mandatory for schedules in which such
	// collisions are impossible - for example, a service running on hourly
	// schedule where a vehicle that is one hour late is not considered to be
	// related to schedule anymore.
	// In YYYYMMDD format.
	StartDate            *string                              `protobuf:"bytes,3,opt,name=start_date" json:"start_date,omitempty"`
	ScheduleRelationship *TripDescriptor_ScheduleRelationship `protobuf:"varint,4,opt,name=schedule_relationship,enum=main.TripDescriptor_ScheduleRelationship" json:"schedule_relationship,omitempty"`
	XXX_extensions       map[int32]proto.Extension            `json:"-"`
	XXX_unrecognized     []byte                               `json:"-"`
}

func (m *TripDescriptor) Reset()         { *m = TripDescriptor{} }
func (m *TripDescriptor) String() string { return proto.CompactTextString(m) }
func (*TripDescriptor) ProtoMessage()    {}

var extRange_TripDescriptor = []proto.ExtensionRange{
	{1000, 1999},
}

func (*TripDescriptor) ExtensionRangeArray() []proto.ExtensionRange {
	return extRange_TripDescriptor
}
func (m *TripDescriptor) ExtensionMap() map[int32]proto.Extension {
	if m.XXX_extensions == nil {
		m.XXX_extensions = make(map[int32]proto.Extension)
	}
	return m.XXX_extensions
}

func (m *TripDescriptor) GetTripId() string {
	if m != nil && m.TripId != nil {
		return *m.TripId
	}
	return ""
}

func (m *TripDescriptor) GetRouteId() string {
	if m != nil && m.RouteId != nil {
		return *m.RouteId
	}
	return ""
}

func (m *TripDescriptor) GetStartTime() string {
	if m != nil && m.StartTime != nil {
		return *m.StartTime
	}
	return ""
}

func (m *TripDescriptor) GetStartDate() string {
	if m != nil && m.StartDate != nil {
		return *m.StartDate
	}
	return ""
}

func (m *TripDescriptor) GetScheduleRelationship() TripDescriptor_ScheduleRelationship {
	if m != nil && m.ScheduleRelationship != nil {
		return *m.ScheduleRelationship
	}
	return TripDescriptor_SCHEDULED
}

// Identification information for the vehicle performing the trip.
type VehicleDescriptor struct {
	// Internal system identification of the vehicle. Should be unique per
	// vehicle, and can be used for tracking the vehicle as it proceeds through
	// the system.
	Id *string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	// User visible label, i.e., something that must be shown to the passenger to
	// help identify the correct vehicle.
	Label *string `protobuf:"bytes,2,opt,name=label" json:"label,omitempty"`
	// The license plate of the vehicle.
	LicensePlate     *string                   `protobuf:"bytes,3,opt,name=license_plate" json:"license_plate,omitempty"`
	XXX_extensions   map[int32]proto.Extension `json:"-"`
	XXX_unrecognized []byte                    `json:"-"`
}

func (m *VehicleDescriptor) Reset()         { *m = VehicleDescriptor{} }
func (m *VehicleDescriptor) String() string { return proto.CompactTextString(m) }
func (*VehicleDescriptor) ProtoMessage()    {}

var extRange_VehicleDescriptor = []proto.ExtensionRange{
	{1000, 1999},
}

func (*VehicleDescriptor) ExtensionRangeArray() []proto.ExtensionRange {
	return extRange_VehicleDescriptor
}
func (m *VehicleDescriptor) ExtensionMap() map[int32]proto.Extension {
	if m.XXX_extensions == nil {
		m.XXX_extensions = make(map[int32]proto.Extension)
	}
	return m.XXX_extensions
}

func (m *VehicleDescriptor) GetId() string {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return ""
}

func (m *VehicleDescriptor) GetLabel() string {
	if m != nil && m.Label != nil {
		return *m.Label
	}
	return ""
}

func (m *VehicleDescriptor) GetLicensePlate() string {
	if m != nil && m.LicensePlate != nil {
		return *m.LicensePlate
	}
	return ""
}

// A selector for an entity in a GTFS feed.
type EntitySelector struct {
	// The values of the fields should correspond to the appropriate fields in the
	// GTFS feed.
	// At least one specifier must be given. If several are given, then the
	// matching has to apply to all the given specifiers.
	AgencyId *string `protobuf:"bytes,1,opt,name=agency_id" json:"agency_id,omitempty"`
	RouteId  *string `protobuf:"bytes,2,opt,name=route_id" json:"route_id,omitempty"`
	// corresponds to route_type in GTFS.
	RouteType        *int32                    `protobuf:"varint,3,opt,name=route_type" json:"route_type,omitempty"`
	Trip             *TripDescriptor           `protobuf:"bytes,4,opt,name=trip" json:"trip,omitempty"`
	StopId           *string                   `protobuf:"bytes,5,opt,name=stop_id" json:"stop_id,omitempty"`
	XXX_extensions   map[int32]proto.Extension `json:"-"`
	XXX_unrecognized []byte                    `json:"-"`
}

func (m *EntitySelector) Reset()         { *m = EntitySelector{} }
func (m *EntitySelector) String() string { return proto.CompactTextString(m) }
func (*EntitySelector) ProtoMessage()    {}

var extRange_EntitySelector = []proto.ExtensionRange{
	{1000, 1999},
}

func (*EntitySelector) ExtensionRangeArray() []proto.ExtensionRange {
	return extRange_EntitySelector
}
func (m *EntitySelector) ExtensionMap() map[int32]proto.Extension {
	if m.XXX_extensions == nil {
		m.XXX_extensions = make(map[int32]proto.Extension)
	}
	return m.XXX_extensions
}

func (m *EntitySelector) GetAgencyId() string {
	if m != nil && m.AgencyId != nil {
		return *m.AgencyId
	}
	return ""
}

func (m *EntitySelector) GetRouteId() string {
	if m != nil && m.RouteId != nil {
		return *m.RouteId
	}
	return ""
}

func (m *EntitySelector) GetRouteType() int32 {
	if m != nil && m.RouteType != nil {
		return *m.RouteType
	}
	return 0
}

func (m *EntitySelector) GetTrip() *TripDescriptor {
	if m != nil {
		return m.Trip
	}
	return nil
}

func (m *EntitySelector) GetStopId() string {
	if m != nil && m.StopId != nil {
		return *m.StopId
	}
	return ""
}

// An internationalized message containing per-language versions of a snippet of
// text or a URL.
// One of the strings from a message will be picked up. The resolution proceeds
// as follows:
// 1. If the UI language matches the language code of a translation,
//    the first matching translation is picked.
// 2. If a default UI language (e.g., English) matches the language code of a
//    translation, the first matching translation is picked.
// 3. If some translation has an unspecified language code, that translation is
//    picked.
type TranslatedString struct {
	// At least one translation must be provided.
	Translation      []*TranslatedString_Translation `protobuf:"bytes,1,rep,name=translation" json:"translation,omitempty"`
	XXX_unrecognized []byte                          `json:"-"`
}

func (m *TranslatedString) Reset()         { *m = TranslatedString{} }
func (m *TranslatedString) String() string { return proto.CompactTextString(m) }
func (*TranslatedString) ProtoMessage()    {}

func (m *TranslatedString) GetTranslation() []*TranslatedString_Translation {
	if m != nil {
		return m.Translation
	}
	return nil
}

type TranslatedString_Translation struct {
	// A UTF-8 string containing the message.
	Text *string `protobuf:"bytes,1,req,name=text" json:"text,omitempty"`
	// BCP-47 language code. Can be omitted if the language is unknown or if
	// no i18n is done at all for the feed. At most one translation is
	// allowed to have an unspecified language tag.
	Language         *string `protobuf:"bytes,2,opt,name=language" json:"language,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *TranslatedString_Translation) Reset()         { *m = TranslatedString_Translation{} }
func (m *TranslatedString_Translation) String() string { return proto.CompactTextString(m) }
func (*TranslatedString_Translation) ProtoMessage()    {}

func (m *TranslatedString_Translation) GetText() string {
	if m != nil && m.Text != nil {
		return *m.Text
	}
	return ""
}

func (m *TranslatedString_Translation) GetLanguage() string {
	if m != nil && m.Language != nil {
		return *m.Language
	}
	return ""
}

func init() {
	proto.RegisterEnum("main.FeedHeader_Incrementality", FeedHeader_Incrementality_name, FeedHeader_Incrementality_value)
	proto.RegisterEnum("main.TripUpdate_StopTimeUpdate_ScheduleRelationship", TripUpdate_StopTimeUpdate_ScheduleRelationship_name, TripUpdate_StopTimeUpdate_ScheduleRelationship_value)
	proto.RegisterEnum("main.VehiclePosition_VehicleStopStatus", VehiclePosition_VehicleStopStatus_name, VehiclePosition_VehicleStopStatus_value)
	proto.RegisterEnum("main.VehiclePosition_CongestionLevel", VehiclePosition_CongestionLevel_name, VehiclePosition_CongestionLevel_value)
	proto.RegisterEnum("main.VehiclePosition_OccupancyStatus", VehiclePosition_OccupancyStatus_name, VehiclePosition_OccupancyStatus_value)
	proto.RegisterEnum("main.Alert_Cause", Alert_Cause_name, Alert_Cause_value)
	proto.RegisterEnum("main.Alert_Effect", Alert_Effect_name, Alert_Effect_value)
	proto.RegisterEnum("main.TripDescriptor_ScheduleRelationship", TripDescriptor_ScheduleRelationship_name, TripDescriptor_ScheduleRelationship_value)
}
